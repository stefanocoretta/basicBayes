{
  "hash": "05ea93470fdf5a596ae5f9ff7a64bd5d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"04 - Poisson and ordinal regression models for count variables and likert scales\"\nauthor: \"Stefano Coretta\"\n---\n\n\n\n## Summary\n\n::: box-note\n- **Gaussian** for Gaussian variables (very rare).\n\n- **Log-normal** for outcome variables that can take only positive (real) values.\n\n- **Bernoulli** for binary outcome variables.\n:::\n\n. . .\n\n::: box-tip\nOther common types of outcome variables:\n\n- Count data: *Poisson* and *negative binomial* models.\n\n- Likert scales: *Ordinal* models.\n\n:::\n\n## Counts of infants' gestures\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngestures <- read_csv(\"data/cameron2020/gestures.csv\")\ngestures_count <- gestures |>\n  filter(months == 11) |> \n  summarise(\n    count = sum(count, na.rm = TRUE),\n    .by = c(background, dyad)\n  )\n\ngestures_count\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 × 3\n   background dyad  count\n   <chr>      <chr> <dbl>\n 1 Bengali    b01       9\n 2 Bengali    b02      18\n 3 Bengali    b03      15\n 4 Bengali    b04      21\n 5 Bengali    b05      13\n 6 Bengali    b06       6\n 7 Bengali    b07       6\n 8 Bengali    b08      19\n 9 Bengali    b09       6\n10 Bengali    b10       1\n# ℹ 50 more rows\n```\n\n\n:::\n:::\n\n\n## Infants' gestures\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngestures_count |> \n  ggplot(aes(background, count, colour = background)) +\n  geom_point() +\n  labs(x = element_blank(), y = \"Number of gestures\") +\n  theme(legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![Number of gestures by infant and group.](05-pois-ord_files/figure-revealjs/fig-gestures-point-1.png){#fig-gestures-point width=960}\n:::\n:::\n\n\n## Infants' gestures: histogram\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngestures_count |> \n  ggplot(aes(count, fill = background)) +\n  geom_histogram(alpha = 0.9, binwidth = 5) +\n  facet_grid(rows = vars(background)) +\n  labs(x = \"Number of gestures\", y = \"Number of infants\", caption = \"Bin width = 5.\") +\n  theme(legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![Histogram of number of gestures by group.](05-pois-ord_files/figure-revealjs/fig-gestures-hist-1.png){#fig-gestures-hist width=960}\n:::\n:::\n\n\n## Poisson regression: code\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngest_pois <- brm(\n  count ~ 0 + background,\n  family = poisson,\n  data = gestures_count,\n  cores = 4,\n  seed = 8712,\n  file = \"data/cache/gest_pois\"\n)\n```\n:::\n\n\n## Poisson regression: posterior predictive check\n\n\n::: {.cell}\n\n```{.r .cell-code}\npp_check(gest_pois, ndraws = 20)\n```\n\n::: {.cell-output-display}\n![Posterior predictive check plot of `gest_pois`.](05-pois-ord_files/figure-revealjs/fig-gest-pois-pp-1.png){#fig-gest-pois-pp width=960}\n:::\n:::\n\n\n## Negative binomial regression: code\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngest_negb <- brm(\n  count ~ 0 + background,\n  family = negbinomial,\n  data = gestures_count,\n  cores = 4,\n  seed = 8258,\n  file = \"data/cache/gest_negb\"\n)\n```\n:::\n\n\n## Negative binomial: posterior predictive check\n\n\n::: {.cell}\n\n```{.r .cell-code}\npp_check(gest_negb, ndraws = 20)\n```\n\n::: {.cell-output-display}\n![Posterior predictive check of `gest_negb`.](05-pois-ord_files/figure-revealjs/fig-gest-negb-pp-1.png){#fig-gest-negb-pp width=960}\n:::\n:::\n\n\n## Negative binomial: predicted counts\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconditional_effects(gest_negb)\n```\n\n::: {.cell-output-display}\n![Predicted counts of gestures by background.](05-pois-ord_files/figure-revealjs/fig-gest-negb-cond-1.png){#fig-gest-negb-cond width=960}\n:::\n:::\n\n\n## Posterior draws\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngest_negb_draws <- as_draws_df(gest_negb)\n\ngest_negb_draws\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A draws_df: 1000 iterations, 4 chains, and 6 variables\n   b_backgroundBengali b_backgroundChinese b_backgroundEnglish shape lprior\n1                  2.6                 2.3                 2.3  1.05   -1.6\n2                  2.7                 2.5                 2.4  0.97   -1.5\n3                  2.6                 2.3                 2.5  0.77   -1.3\n4                  2.6                 2.6                 2.0  1.07   -1.6\n5                  2.8                 2.1                 2.2  1.70   -2.2\n6                  2.5                 2.3                 2.8  1.39   -2.0\n7                  2.4                 2.3                 2.7  1.29   -1.9\n8                  2.5                 2.7                 2.2  0.83   -1.4\n9                  2.7                 2.1                 2.7  0.97   -1.5\n10                 2.7                 2.8                 2.5  0.81   -1.4\n   lp__\n1  -211\n2  -211\n3  -212\n4  -212\n5  -218\n6  -217\n7  -215\n8  -212\n9  -214\n10 -213\n# ... with 3990 more draws\n# ... hidden reserved variables {'.chain', '.iteration', '.draw'}\n```\n\n\n:::\n:::\n\n\n## Predicted counts\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngest_negb_draws <- gest_negb_draws |> \n  mutate(\n    Bengali = exp(b_backgroundBengali),\n    Chinese = exp(b_backgroundChinese),\n    English = exp(b_backgroundEnglish)\n  )\n\ngest_negb_draws |> select(Bengali:English)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4,000 × 3\n   Bengali Chinese English\n     <dbl>   <dbl>   <dbl>\n 1    13.0    9.86    9.83\n 2    14.4   11.8    10.5 \n 3    14.0    9.74   12.5 \n 4    13.9   13.7     7.16\n 5    17.1    8.31    9.35\n 6    12.2    9.90   16.3 \n 7    11.5   10.3    14.3 \n 8    12.4   15.1     8.72\n 9    14.7    8.29   15.0 \n10    15.1   16.8    11.9 \n# ℹ 3,990 more rows\n```\n\n\n:::\n:::\n\n\n## Credible intervals: counts\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngest_negb_draws |> \n  select(Bengali:English) |> \n  pivot_longer(Bengali:English, names_to = \"coef\", values_to = \"est\") |> \n  group_by(coef) |> \n  summarise(\n    ci_lo = round(quantile2(est, probs = 0.025)),\n    ci_hi = round(quantile2(est, probs = 0.975))\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 3\n  coef    ci_lo ci_hi\n  <chr>   <dbl> <dbl>\n1 Bengali     9    24\n2 Chinese     7    20\n3 English     6    16\n```\n\n\n:::\n:::\n\n\n## Summary I\n\n::: box-tip\n- Count data (like the number of infants' gestures, or number of occurrences in a corpus) can be modelled with a Poisson distribution.\n\n- If the data has over-dispersion, the negative binomial distribution might be better.\n\n- The model estimates are in logged counts. Use `exp()` to convert them back to counts.\n:::\n\n## Likert scales\n\n\n::: {.cell}\n\n```{.r .cell-code}\nemilianto <- readRDS(\"data/hampton2023/emilianto_attitude.rds\")\n\nemilian <- emilianto |> \n  filter(language == \"Emilian\")\n\nemilian |> select(comprehend, speak, commuter, age)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 434 × 4\n   comprehend speak commuter   age\n   <ord>      <ord> <chr>    <dbl>\n 1 VG         VG    Sí          57\n 2 G          50/50 No          20\n 3 VG         VG    No          50\n 4 50/50      NO    No          25\n 5 VG         VG    No          65\n 6 VG         VG    No          56\n 7 VG         VG    No          62\n 8 VG         VG    No          65\n 9 VG         VG    No          63\n10 VG         G     No          61\n# ℹ 424 more rows\n```\n\n\n:::\n:::\n\n\n## An ordinal model of comprehension: code\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncompr_ord <- brm(\n  comprehend ~ cs(commuter),\n  family = acat(link = \"probit\"),\n  data = emilian,\n  cores = 4,\n  seed = 1523,\n  file = \"data/cache/compr_ord\"\n)\n```\n:::\n\n\n## Predicted probability of each \n\n\n::: {.cell}\n\n```{.r .cell-code}\nconditional_effects(compr_ord, categorical = TRUE)\n```\n\n::: {.cell-output-display}\n![Predicted probability of comprehension levels by commuter status.](05-pois-ord_files/figure-revealjs/fig-compr-ord-cond-1.png){#fig-compr-ord-cond width=960}\n:::\n:::\n\n\n## An ordinal model of speaking proficiency: code\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspeak_ord <- brm(\n  speak ~ age,\n  family = acat(link = \"probit\"),\n  data = emilian,\n  cores = 4,\n  seed = 1523,\n  file = \"data/cache/speak_ord\"\n)\n```\n:::\n\n\n## Predicted probability of speaking proficiency\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconditional_effects(speak_ord, categorical = TRUE)\n```\n\n::: {.cell-output-display}\n![Predicted probability of speaking proficiency levels by age.](05-pois-ord_files/figure-revealjs/fig-speak-ord-1.png){#fig-speak-ord width=960}\n:::\n:::\n\n\n\n## Summary II\n\n::: box-note\n- Likert scale data can be modelled with a an ordinal distribution.\n\n- Ordinal models estimate the probability of each level in the scale.\n:::\n",
    "supporting": [
      "05-pois-ord_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}